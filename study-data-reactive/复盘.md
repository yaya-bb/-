
## 1.数据响应式原理
### 1.1什么是数据响应式？
【非侵入式】当数据改变后，Vue会通知到使用该数据的代码。数据响应式原理的核心是采用了数据劫持结合发布者-订阅者模式的方式来实现数据的响应式，通过Object.defineProperty()对数据进行拦截，把这些属性全部转换为getter/setter，get()方法可以读取数据、收集数据，set()方法可以改写数据，在数据变动时会对数据进行比较，如果数据发生了变化，会发布信息通知订阅者，更新视图。
## 1.2侦测数据变化的方法—Object.defineProperty()
该方法会直接在一个对象上定义一个新属性，或者修改一个对象现有属性，并返回对象。
功能：将属性转换为getter/setter的形式来追踪变化。
getter：读取数据会触发；收集观察者
setter：修改数据会触发，去通知getter中的依赖数据发生变化；通知观察者进行更新视图或处理事务。
Vue2中利用闭包将Object.defineProperty封装到defineReactive方法中，临时变量也存放在此方法中。
## 1.3定义defineReactive函数
实现数据劫持，来实现监听数据的改变和读取(属性的getter和setter)
Object.defineProperty把数据转为getter和setter，并为每个数据添加一个订阅列表的过程。
此函数还需要用到observe函数以及Dep函数
**observe：**
【用于监听对象嵌套对象】
**Dep：**
【用于收集依赖】
defineProperty函数执行过程中新建了一个Dep，不需要设置临时变量，而是闭包在了属性的getter和setter中，因此每个属性都有一个唯一的Dep与其对应
get: 属性的getter函数。当访问该属性时，会调用此函数。执行时不闯入任何参数，但是会传入this对象(由于继承关系，这里的this并不一定是定义该属性的对象)。该函数的返回值会被用作属性的值
set: 属性的setter函数。当属性值被改时，会调用此函数。该方法接受一个参数(也就是被赋予的新值)，会传入赋值的this对象，默认为undefined
```
import observe from "./observe";
import Dep from "./Dep";
// 给对象obj定义一个响应式的属性
// obj: 传入的数据，key:监听的属性,value:闭包环境提供的周转变量
export default function defineReactive (obj, key, val) {
  // 每个数据都要维护一个属于自己的数组，用来存放依赖自己的watcher
  // 创建信息中心
  const dep = new Dep();
  if(arguments.length == 2) {
    val = obj[key];
  }
  // 子元素要进行observe,至此形成了递归。这个递归不是函数自己调用自己，而是多个函数，类循环调用
  let childOb = observe(val);
  // 可以使用Object.defineProperty去定义一些隐藏的属性
  // 对obj的key进行属性拦截
  // val的值相当于get和set这两个函数闭包中的环境
  // 闭包是一定要有内外两层函数嵌套，get、set是内层，defineReactive是外层
  Object.defineProperty(obj, key, {
    // 可枚举
    enumerable: true,
    // 可以被配置，比如可以被delete
    configurable: true,
    // 是否可写
    // writable: true
    // get和value不能同时使用
    // getter/setter 需要变量周转才能工作
    // 临时变量不是特别美观，可以封装到一个函数中，利用函数的闭包特性
    // 闭包就是函数外部的作用域
    // getter 获取数据
    get() {
      console.log('访问'+ key + '属性');
      // 如果现在处于收集依赖阶段
      // 数据变化时，通知添加订阅者
      if(Dep.target) {
        dep.depend();
        // 数组情况，判断有没有子元素
        if(childOb) {
          // 数组收集依赖
          childOb.dep.depend();
        }
      }
      return val;
    },
    // setter对变量的赋值
    set(newValue) {
      // 负责劫持
      console.log('修改' + key + '属性', newValue);
      // 如果传入的值相等就不用修改
      if(val == newValue) {
        return;
      }
      // 修改数据
      val = newValue;
      // 当设置了新值，这个新值也要被observe
      // 新值如果是对象，仍然需要递归遍历处理
      childOb = observe(newValue);
      // 触发依赖
      // 发布订阅模式，通知dep信息中心
      dep.notify();
    }
  });
}
```
# 对象的响应式处理 ↓
## 1.4 递归侦测对象全部属性object
### 1.4.1 observe函数
由于defineProperty函数不能监听到对象嵌套对象,
所以我们要创建一个Observer类 —>将一个正常的object转换为每个层级的属性都是响应式(可以被侦测的)的object
此函数还需要Observer函数
**Observer：**
【把一个object中的所有数据(包括子数据)都转成响应式，它会侦测object中所有的数据的变化】
 
1. 监听value尝试创建Observer实例，如果value已经是响应式数据，就不需要再创建Observer实例，直接返回已经创建的Observer实例即可，避免重复侦测value变化的问题
import Observer from "./Observer.js";
```
/*
* 监听value尝试创建Observer实例，如果value已经是响应式数据，就不需要再创建Observer实例，
* 直接返回已经创建的Observer实例即可，避免重复侦测value变化的问题
*/
export default function observe(value) {
  // 如果value不是对象，什么都不做(表示该递归到的是基本类型，其变化可被侦听的)
  if(typeof value != 'object')
  {
    return;
  }
  // Observer实例
  // 定义ob
  let ob;
  // 第一步是调observe(obj)来触发全部东西
  // 第二步是看obj身上有没有__ob__
  // 如果没有就会new Observer()
    /*
      将产生的实例，添加到__ob__上
    */
  // 遍历下一层属性，逐个defineReactive
    /*
      当设置某个属性值的时候，会触发set，里面有newValue，
      这个newValue也得被observe()一下
    */
  // __ob__是value上的属性，其值是对应的Observer实例(表示其已经是可侦听的状态)
  if(typeof value.__ob__ !== 'undefined') {
    ob = value.__ob__;
  } else {
    // 是对象且该上属性还是未能够侦听状态
    // 此时构造器就会被执行
    ob = new Observer(value);
  }
  return ob;
}
```
## 1.5 Observer类
把一个object中的所有数据(包括子数据)都转成响应式，它会侦测object中所有的数据的变化。
对象的侦测属性还需要添加Dep函数、def函数、defineReactive函数【其余的函数需求是用于数组的侦测】
**Dep:**
【
**def：**
【给实例添加__ob__属性，值是Observer的实例，且不可枚举】
**defineReactive：**
【将object的所有数据转成响应式】
1. __ob__的作用可以用来标记当前value是否已经被Observer转换为响应式数据了； 而且可以通过value.__ob__来访问Observer的实例
2. walk：将一个正常的object转换为每个层级的属性都是响应式(可以被侦测的)的object【通过循环遍历属性，使用defineReactive方法将属性变为响应式】
```
import { def } from './utils.js'
import defineReactive from './defineReactive.js';
import { arrayMethods } from './array.js';
import observe from './observe.js';
import Dep from './Dep.js';
// Observer 将一个正常的object转换为每个层级的属性都是响应式(可以被侦测的)的object
export default class Observer {
  // 构造器
  // 类需要思考如何被实例化
  constructor(value) {
    // 每个Observer的实例，成员中都有一个Dep的实例
    // 将__ob__绑在dep上
    // 当数据被修改时，就会触发dep
    this.dep = new Dep();

    // 添加__ob__属性，实际上是不可枚举属性
    // 给实例this，一定要注意，构造函数中的this不是表示类本身，而是表示实例)，给实例添加了__ob__属性，值是这次new的实例
    // 定义一个对象属性
    def(value, '__ob__', this, false);
    console.log('构造器', value);
    // 检查是数组还是对象
    if(Array.isArray(value)) {
      // 如果是数组，要强行将这个数组的原型指向arrayMethods
      Object.setPrototypeOf(value, arrayMethods);
      // 让数组变得observe
      this.observeArray(value);
    } else {
      // 将一个正常的object转换为每个层级的属性都是响应式(可以被侦测的)的object
      this.walk(value);
    }
  };
  // 遍历，遍历value里面的每一个key,让每一个key设置为defineReactive
  // 对于对象上的属性进行遍历，将其变为响应式
  walk(value) {
    // defineReactive被Observer的walk方法调用
    for(let k in value) {
      // 把value的k属性变成reactive
      // 通过这步操作，外层变成响应式
      defineReactive(value, k);
    }
  }
  // 数组的特殊遍历
  observeArray(arr) {
    for(let i = 0; i < arr.length; i++) {
      /*
      * Observer类会附加到每一个被侦测的object上，一旦被附加，Observer会将object所有属性转换为getter/setter的形式
      */
      // 逐项进行observe
      observe(arr[i]);     
    }
  }
}
```