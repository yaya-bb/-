# 1.理解虚拟DOM和diff算法
## 1.1什么是虚拟DOM？
从本质上来说，虚拟DOM是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。虚拟DOM使DOM的抽象，这个对象是更加轻量级的对DOM的描述。
## 1.2 为什么要用虚拟DOM？
1. 保证性能下限，在不进行手动优化的情况下，提供过得去的性能。
对比一下修改DOM时真实DOM操作和虚拟DOM的过程，来看一下它们重排重绘的性能消耗：
● 真实DOM：生成HTML字符串+重建所有的DOM元素
● 虚拟DOM：生成vNode+DOMdiff+必要的dom更新
虚拟DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道：框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。
2. 跨平台
虚拟DOM本质上是JavaScript的对象，它可以很方便的跨平台操作。比如服务器渲染、uniapp等
## 2.1diff算法简介
新虚拟DOM和旧虚拟DOM进行diff(精细化比较),算出应该如何最小量更新，最后反映到真正的DOM上【虚拟节点变成DOM节点】在Vue里面叫做patch
## 2.2diff算法原理
在新老虚拟DOM进行对比：
● 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换
● 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
● 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作(diff核心)
● 匹配时，找到相同的子节点，递归比较子节点
在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂度降低至O(n),也就是说只有当新旧children都为多个子节点时才需要用diff算法进行精细化比较。
## 2.3diff算法什么时候执行？
在页面首次渲染的时候会调用一次patch并创建新的vnode，不会进行更深层次的比较
然后在组件中数据发生变化时，会触发setter然后通过notify通知Watcher，对应的Watcher会通知更新并执行更新函数，它会执行render函数获取新的虚拟DOM，然后执行patch对比上次渲染结果的老的虚拟DOM，并计算出最小的变化，然后再去根据这个最小的变化去更新DOM
2.4diff算法的优化
1.只比较同一层级，不跨级比较
diff过程只会把同颜色并且同一层级的DOM进行比较，这样能够简化比较次数

2.比较标签名
如果同一层级的标签名不同，就直接移除老的虚拟DOM对应的节点，不继续按这个树状结构左深度比较。

3.比较key
如果标签名相同，key也相同，就会认为是相同节点，也不继续按这个树状结构做深度比较。
key的作用

比如有一个列表，我们需要在中间插入一个元素，会导致后面的元素进行重新渲染。如图li1,li2不会重新渲染，li3,li4,li5都会重新渲染。
因为在不使用key或列表的index作为key的时候，每个元素对应的位置关系都是index，上图中的结果导致我们插入的元素到后面的全部元素，对应的位置关系都发生了变更，所以全部都会执行更新操作，而我们希望的是只渲染添加的元素，其他的元素不再进行重新渲染。
而再使用唯一key的情况下，每个元素对应的位置关系都是key，看一下使用唯一key值的情况下，这样图中的li3和li4就不会重新渲染，因为元素内容没有发生改变，对应的位置关系也没有发生改变。

因此，不建议使用index作为key。
原因是：使用index作为key和没写基本上没区别。因为不管数组的顺序怎么颠倒，index都是0,1,2...这样排列，导致Vue会复用错误的旧子节点，做很多额外的工作。
总结：
● 在diff算法中，key是vnode的唯一标记，key的作用主要是为了更高效的更新虚拟DOM，因为它可以非常精确的找到相同节点，因此patch过程会非常高效
● Vue在patch过程中会判断两个节点是不是相同的节点时，key是一个必要条件。在渲染列表时，如果不写key，Vue在比较的时候，就可能会导致频繁更新元素，使整个patch过程比较低效，影响性能。
● 应该避免使用数组下标作为key，因为key值不是唯一的话，也可能会出现上面图中的问题，还有比如在使用相同标签元素过渡切换的时候，就会导致只替换其内部属性，而不会触发过渡效果。这个时候key的作用是用来表示一个独立的元素。
● Vue判断两个节点是否相同时，主要判断两者的元素类型和key等。因为带key就不是就地复用。在checkSameVnode函数中a.key===b.key对比中可以避免就地复用。所以会更加准确。
3.实现diff算法

## 3.1h函数【简易版】
用来产生虚拟节点(vnode)
1. 判断第三个参数是否是一个字符串或是数字。如果是字符串或数字，直接返回vnode
2. 判断第三个参数是否是一个数组。声明一个数组，用于存储子节点，需要遍历数组，这里需要判断每一项是否是一个对象(因为vnode返回一个对象并且一定会有sel属性)，但是不需要执行每一项，因为在数组中已经执行了h函数。其实，并不是函数递归进行调用(自己调用自己)，而是一层一层的嵌套
3. 判断第三个参数是否是一个对象。直接将这个对象赋值给children，并返回vnode
```
import vnode from './vnode';

// 这个函数必须接受3个参数，缺一不可
// 相当于它的重载功能较弱
/*
*  也就是说，调用的时候形态必须是下面的三种之一:
*  形态一：h('div', {}, '文字');
*  形态二：h('div', {}, []);
*  形态三：h('div', {}, h());
*/
export default function(sel, data, c) {
  // 检查参数的个数
  if(arguments.length != 3) {
    throw new Error('h() takes exactly 3 arguments');
  }
  // 检查参数c的类型
  if(typeof c == 'string' || typeof c == 'number') {
    // 说明现在调用h函数是形态一
    return vnode(sel, data, undefined, c, undefined);
  } else if(Array.isArray(c)) {
    // 说明现在调用h函数是形态二
    let children = [];
    // 遍历c,收集children
    for(let i = 0; i < c.length; i++) {
      // 检查c[i]必须是一个对象, 如果不满足
      if(!(typeof c[i] == 'object' || c.hasOwnProperty('sel'))) {
        throw new Error('h() takes an array of objects or selectors');
      }
      children.push(c[i]);
    }
    // 循环结束了，就说明children收集完毕，此时可以返回虚拟节点，有children属性
    return vnode(sel, data, children, undefined, undefined);
  } else if(typeof c == 'object' && c.hasOwnProperty('sel')) {
    // 说明现在调用h函数是形态三
    // 传入的c是唯一的children,不用执行c，因为测试语句中已经执行了c
    let children = [c];
  } else {
    throw new Error('此h函数必须传入三个参数')
  }
}
```

## 3.2vnode函数
用于创建虚拟节点
```
export default function(sel, data, children, text, elm) {
  const key = data.key;
  // sel 选择器， data 属性， children 子节点，text 文本内容， elm 虚拟节点绑定的真实DOM节点
  return {
    sel,
    data,
    children,
    text,
    elm,
    key
  }
}
```
## 3.3patch函数
首先判断旧节点是否是虚拟节点，不是则将旧节点变为虚拟节点【vnode函数】，如果是则判断是否是同一个节点类型，在这个判断中是则进行精细化比较，不是则进行暴力删除
```
import vnode from "./vnode";
import createElement from "./createElement";
import patchVnode    from "./patchVnode";
export default function(oldVnode, newVnode) {
  // 判断传入的第一个参数，是DOM节点还是虚拟节点?
  if(oldVnode.sel == '' || oldVnode.sel == undefined) {
    // 传入的第一个参数是DOM节点，此时要包装为虚拟节点
    // toLowerCase()变成小写字母
    oldVnode = vnode(oldVnode.tagName.toLowerCase(), {}, [], undefined, oldVnode);
  }
  // 判断oldVnode和newVnode是不是同一个节点
  if(oldVnode.key == newVnode.key && oldVnode.sel == newVnode.sel) {
    patchVnode(oldVnode, newVnode);
  } else {
    console.log('暴力插入新的，删除旧的');
    // 需要.elm得到  
    let newVnodeElm = createElement(newVnode);
    if(oldVnode.elm.parentNode && newVnodeElm) {
      // 插入到老节点之前
      oldVnode.elm.parentNode.insertBefore(newVnodeElm, oldVnode.elm);
    }
    // 删除老节点
    oldVnode.elm.parentNode.removeChild(oldVnode.elm);
  }
}
```
补充知识
appendChild():
是在父节点中的子节点列表的末尾添加新的节点(相对于父节点来说)【添加后属于父子关系】
insertBefore():
是在已有的节点前添加新的节点(相对于子节点来说)【添加后属于兄弟关系】
parentNode属性:
该属性可指定元素对象后获取该元素的父节点元素
3.4createElement函数
将vNode转换为真实DOM【上树】
```
//真正创建节点.将vnode创建为DOM
export default function createElement(vnode){
  //创建一个DOM节点，现在这个节点还是孤儿节点，不进行插入
  let domNode = document.createElement(vnode.sel)
  //有子节点还是有文本
  if(vnode.text != '' && (vnode.children == undefined || vnode.children.length == 0)){
    //文本-使用innerText直接进行上树
    domNode.innerText = vnode.text;
    
  }else if(Array.isArray(vnode.children) && vnode.children.length > 0){
    //内部是子节点，就要递归创建节点
    for(let i =0 ;i<vnode.children.length;i++){
      //得到当前这个children
      let children = vnode.children[i];
      console.log(children);
      //创建出它的DOM，一旦调用createElement意味着：创建出DOM了，并且他的elm属性指向了
      //创建出的DOM，但是还没有上树，是一个孤儿节点
      let chDOM = createElement(children);
      //上树
      domNode.appendChild(chDOM)
    }
  }
  //补充elm属性
  vnode.elm = domNode;
  //返回elem，elm属性是个纯DOM对象
  return vnode.elm;
}
```